"""
The geometry module.

This module contains miscellaneous geometry functions for expyriment.

"""

__author__ = 'Florian Krause <siebenhundertzehn@gmail.com>, \
Oliver Lindemann <lindemann09@gmail.com>'
__version__ = '0.6.2'
__revision__ = '23032f47ffea'
__date__ = 'Wed Dec 12 15:49:59 2012 +0100'

import math as _math
import expyriment as _expyriment


def coordinates2position(coordinate):
    """Convert a coordinate on the screen to an expyriment position.

    Keyword arguments:
    coordinate -- the coordinate (x,y) to convert

    """

    screen_size = _expyriment._active_exp.screen.surface.get_size()
    return (coordinate[0] - screen_size[0] / 2,
            - coordinate[1] + screen_size[1] / 2)

def position2coordinate(position):
    """Convert an expyriment position to a coordinate on screen.

    Keyword arguments:
    position -- the position (x,y) to convert

    """

    screen_size = _expyriment._active_exp.screen.surface.get_size()
    return (position[0] + screen_size[0] / 2,
            - position[1] + screen_size[1] / 2)

def points_to_vertices(points):
    """Returns vertex representation of the points (int, int) in xy-coordinates

    Keyword arguments:
    points --- list of points (int ,int)
    """
    vtx = []
    for i in range(1, len(points)):
        vtx.append((points[i][0] - points[i - 1][0], points[i][1] - points[i - 1][1]))
    return vtx

def lines_intersect(pa, pb, pc, pd):
    """Return true if two line segments are intersecting

    Keyword arguments:
    pa -- point 1 of line 1 (misc.XYPoint)
    pb -- point 2 of line 1 (misc.XYPoint)
    pc -- point 1 of line 2 (misc.XYPoint)
    pb -- point 2 of line 2 (misc.XYPoint)

    return true or false
    """
    def ccw(pa, pb, pc):
        return (pc._y - pa._y) * (pb._x - pa._x) > (pb._y - pa._y) * (pc._x - pa._x)

    return ccw(pa, pc, pd) != ccw(pb, pc, pd) and ccw(pa, pb, pc) != ccw(pa, pb, pd)

class XYPoint:
    """ The Expyriment point class """
    def __init__(self, x=None, y=None, xy=None):
        """Initialize a XYPoint.

        Keyword arguments:
        x,y values as two numbers x, y
        or as tuple xy=(x,y)

        """

        if x is None:
            if xy is None:
                self._x = 0
                self._y = 0
            else:
                self._x = xy[0]
                self._y = xy[1]
        elif y is None:
            #if only a tuple is specified: e-g. Point((23,23))
            self._x = x[0]
            self._y = x[1]
        else:
            self._x = x
            self._y = y

    def __repr__(self):
        return  "(x={0}, y={1})".format(self._x, self._y)

    @property
    def x(self):
        """Getter for x"""
        return self._x

    @x.setter
    def x(self, value):
        """Getter for x"""
        self._x = value

    @property
    def y(self):
        """Getter for y"""
        return self._y

    @y.setter
    def y(self, value):
        """Getter for y"""
        self._y = value

    @property
    def tuple(self):
        return (self._x, self._y)

    @tuple.setter
    def tuple(self, xy_tuple):
        self._x = xy_tuple[0]
        self._y = xy_tuple[1]

    def move(self, v):
        """Move the point along the coodinates specified by the vector v.

        Keyword arguments:
        v -- movement vector (XYPoint)

        """

        self._x = self._x + v._x
        self._y = self._y + v._y
        return self

    def distance(self, p):
        """Return euclidian distance to the points (p).

        Keyword arguments:
        p -- the referece point (XYPoint)

        """

        dx = self._x - p._x
        dy = self._y - p._y
        return _math.sqrt((dx * dx) + (dy * dy))

    def rotate(self, degree, rotation_centre=(0, 0)):
        """Rotate the point counterclockwise in degree around rotation_centre.

        Keyword arguments:
        degree          -- degree of rotation (int) (default=(0, 0) )
        rotation_center -- the rotation center (x=int, y=int)

        """

        p = XYPoint(self._x - rotation_centre[0], self._y - rotation_centre[1])
        #cart -> polar
        ang = _math.atan2(p._x, p._y)
        r = _math.sqrt((p._x * p._x) + (p._y * p._y))
        ang = ang - ((degree / 180.0) * _math.pi);
        #polar -> cart
        self._x = r * _math.sin(ang) + rotation_centre[0]
        self._y = r * _math.cos(ang) + rotation_centre[1]
        return self


    def is_inside_polygon(self, point_list):
        """Return true if point is inside a given polygon.

        Keyword arguments:
        point_list - the point list defining the polygon

        """

        n = len(point_list)
        inside = False

        p1 = point_list[0]
        for i in range(n + 1):
            p2 = point_list[i % n]
            if self._y > min(p1._y, p2._y):
                if self._y <= max(p1._y, p2._y):
                    if self._x <= max(p1._x, p2._x):
                        if p1._y != p2._y:
                            xinters = (self._y - p1._y) * (p2._x - p1._x) / (p2._y - p1._y) + p1._x
                        if p1._x == p2._x or self._x <= xinters:
                            inside = not inside
            p1 = p2

        return inside
