"""MIDI output.

This module contains a class implementing a MIDI output device.

"""

__author__ = 'Florian Krause <siebenhundertzehn@gmail.com>, \
Oliver Lindemann <lindemann09@gmail.com>'
__version__ = '0.6.2'
__revision__ = '23032f47ffea'
__date__ = 'Wed Dec 12 15:49:59 2012 +0100'


import _midiout_defaults as defaults
import expyriment
from expyriment.io._input_output import Output

try:
    from pygame import midi as _midi
    _midi.init()
except:
    _midi = None

class MidiOut(Output):
    """A class implementing a MIDI output.

    EXPERIMENTAL!
    Due to a bug in Pygame's midi module, closing a MidiOut (or the programme)
    will cause an error message. Until this is fixed in Pygame, MidiOut will
    stay in extras.

    """

    @staticmethod
    def get_devices():
        """Get a list of all MIDI output devices connected to the system."""

        if _midi is None:
            return
        outdevices = []
        all_ids = _midi.get_count()
        for device_id in all_ids:
            info = _midi.get_device_info(device_id)
            if info[3] == 1:
                outdevices.add([device_id, info[1]])
        return outdevices

    def __init__(self, device, latency=None, buffer_size=None):
        """Create a MIDI output.

        Keyword arguments:
        device       -- the id or name of the MIDI device (int or str)
        latency      -- delay in ms applied to timestamp (int) (optional)
        buffer_size  -- the number of events to be buffered (int) (optional)

        """

        import types
        if type(_midi) is not types.ModuleType:
            raise ImportError("""Sorry, MIDI output is not supported on this computer.""")

        if not expyriment._active_exp.is_initialized:
            raise RuntimeError(
                "Cannot create MidiOut before expyriment.initialize()!")
        _midi.init()
        Output.__init__(self)
        self._id = device
        if buffer_size is None:
            buffer_size = defaults.midiout_buffer_size
        self._buffer_size = buffer_size
        if latency is None:
            latency = defaults.midiout_latency
        self._latency = latency
        self.output = _midi.Output(device, latency, buffer_size)

    @property
    def id(self):
        """Getter for id."""

        return self._id

    @property
    def buffer_size(self):
        """Getter for buffer_size."""

        return self._buffer_size

    @property
    def latency(self):
        """Getter for latency."""

        return self._latency

    def close(self, abort=False):
        """Close the MIDI interface.

        Keyword arguments:
        abort -- abort messages in the buffer (bool) (default=True)

        """

        if abort:
            self.output.abort()
        self.output.close()

    def abort(self):
        """Terminates outgoing messages immediately."""

        self.output.abort()

    def send(self, event_list):
        """Send a list of MIDI events.

        Each event should have the following format:
            [[status, data1, data2, data3], timestamp]

        Note that the data fields are optional.

        Keyword arguments:
        event_list -- the list of events to send (list)

        """

        self.output.write(event_list)

    def send_short(self, status, data1=0, data2=0):
        """Send MIDI events of 3 bytes or less.

        Keywoard arguments:
        status -- the status of the event to send (int)
        data1  -- data1 of the event to send (int) (optional)
        data2  -- data2 of the event to send (int) (optional)

        """

        self.output.write_short(status, data1, data2)


    def send_sysex(self, timestamp, message):
        """Send a System Exlusive message.

        Keyword arguments:
        timestamp -- when (in ms) to send the message (int)
        message   -- the message to send (str or list)

        """

        self.output.wirte_sys_ex(timestamp, message)

    def select_instrument(self, instrument_id, channel=0):
        """Select an instrument.

        Keyword arguments:
        instrument_id -- the id (0-127) of the instrument (int)
        channel       -- the MIDI channel for the instrument (int) (default=0)

        """

        self.output.set_instrument(instrument_id, channel)

    def send_note_on(self, note, velocity=None, channel=0):
        """Send a note-on event.

        Keyword arguments:
        note     -- the note value (int)
        velocity -- the velocity of the note (int) (optional)
        channel  -- the MIDI channel of the note (int) (default=0)

        """

        self.output.note_on(note, velocity, channel)

    def send_note_off(self, note, velocity=None, channel=0):
        """Send a note-off event.

        Keyword arguments:
        note     -- the note value (int)
        velocity -- the velocity of the note (int) (optional)
        channel  -- the MIDI channel of the note (int) (default=0)

        """

        self.output.note_off(note, velocity, channel)
