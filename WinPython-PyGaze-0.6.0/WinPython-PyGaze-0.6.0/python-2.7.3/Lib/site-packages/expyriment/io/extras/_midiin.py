"""MIDI input.

This module contains a class implementing a MIDI input device.

"""

__author__ = 'Florian Krause <siebenhundertzehn@gmail.com>, \
Oliver Lindemann <lindemann09@gmail.com>'
__version__ = '0.6.2'
__revision__ = '23032f47ffea'
__date__ = 'Wed Dec 12 15:49:59 2012 +0100'


import _midiin_defaults as defaults
import expyriment
from expyriment.misc import Clock
from expyriment.io._keyboard import Keyboard
from expyriment.io._input_output import Input

import time

try:
    from pygame import midi as _midi
    _midi.init()
except:
    _midi = None


class MidiIn(Input):
    """A class implementing a MIDI input.

    EXPERIMENTAL!
    Due to a bug in Pygame's midi module, closing a MidiIn (or the programme)
    will cause an error message. Until this is fixed in Pygame, MidiIn will
    stay in extras.

    """

    @staticmethod
    def get_devices():
        """Get a list of all MIDI input devices connected to the system."""

        if _midi is None:
            return
        indevices = []
        all_ids = _midi.get_count()
        for device_id in all_ids:
            info = _midi.get_device_info(device_id)
            if info[2] == 1:
                indevices.add([device_id, info[1]])
        return indevices

    def __init__(self, device, buffer_size=None):
        """Create a MIDI input.

        Keyword arguments:
        device       -- the id or name of the MIDI device (int or str)
        buffer_size  -- the number of events to be buffered (int) (optional)

        """

        import types
        if type(_midi) is not types.ModuleType:
            raise ImportError("""Sorry, MIDI input is not supported on this computer.""")

        if not expyriment._active_exp.is_initialized:
            raise RuntimeError(
                "Cannot create MidiIn before expyriment.initialize()!")
        _midi.init()
        Input.__init__(self)
        self._id = device
        if buffer_size is None:
            buffer_size = defaults.midiin_buffer_size
        self._buffer_size = buffer_size
        self.input = _midi.Input(device, buffer_size)

    @property
    def id(self):
        """Getter for id."""

        return self._id

    @property
    def buffer_size(self):
        """Getter for buffer_size."""

        return self._buffer_size

    def read(self, num_events=1):
        """Read MIDI events from device.

        Returns a list with timestamped midi events.

        A timestpamed midi event will look like this:
            [[status, data1, data2, data3], timestamp]

        Keyboard arguments:
        num_events -- the number of events to read (int) (default=1)

        """

        if self.input.poll():
            expyriment._active_exp._event_file_log(
                    "MIDI In ({0}),received".format(self.id), 2)
            return self.input.read(num_events)

    def clear(self):
        """Clear the input buffer.

        This can take more than 1 ms!

        """

        for _i in range(self._buffer_size):
            self.input.read(1)
            expyriment._active_exp._event_file_log(
                "MIDI In ({0}),cleared".format(self.id), 2)

    def wait(self, events, duration=None):
        """Wait for (a) certain event(s).

        Returns the found event and the reaction time.

        Events to wait for are in the form of a list wtih 4 elements and do
        not include a timestamp:
            [status, data1, data2, data3]


        Keyword arguments:
        events   -- the event(s) to wait for (event or list of events)
        duration -- the maximal time to wait in ms (int) (optional)

        """

        start = Clock._cpu_time()
        rt = None
        _event = None
        self.clear()
        if type(events) is list and \
           len(events) == 4 and \
           type(events[0]) is int and \
           type(events[1]) is int and \
           type(events[2]) is int and \
           type(events[3]) is int:
            events = [events]
        done = False
        while not done:
            expyriment._active_exp._execute_wait_callback()
            event = self.read(1)
            if event is not None and event[0][0] in events:
                rt = int((Clock._cpu_time() - start) * 1000)
                _event = event[0][0]
                done = True
                break
            if Keyboard.process_control_keys():
                done = True
                break
            if duration:
                if int((Clock._cpu_time() - start) * 1000) >= duration:
                    done = True
                    break

            time.sleep(0.0005)

        expyriment._active_exp._event_file_log(
                "MIDI In ({0}),received,{1},wait".format(self.id, _event), 2)
        return _event, rt
